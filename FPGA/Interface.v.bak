module Interface (
    input             CLOCK_50,

    // --- Lado do HPS (Qsys PIOs) ---
    input      [31:0] hps_data_in,
    input             hps_control_in,
    output reg [31:0] fpga_status_out,

    // --- Lado do FPGA (Controller e RAM) ---
    output reg        cmd_reset_pulse,
    output reg        cmd_zoom_in_pulse,
    output reg        cmd_zoom_out_pulse,
    output reg        cmd_return_pulse,
    output reg [1:0]  cmd_algorithm_select,
    output reg        cmd_multiple_sw_error,
    output reg        cmd_no_sw_error,
    input             controller_done,
    input      [2:0]  controller_zoom_level,

    // Conexão com a ImgRam (Porta A de Escrita)
    output reg [14:0] ram_wraddress,
    output reg [7:0]  ram_data_in,
    output reg        ram_wren
);

    // --- 1. Sincronização e Detecção de Pulso (CDC) ---
    reg hps_control_sync_r1 = 1'b0;
    reg hps_control_sync_r2 = 1'b0;
    reg hps_control_sync_last_r = 1'b0;
    
    always @(posedge CLOCK_50) begin
        hps_control_sync_r1     <= hps_control_in;
        hps_control_sync_r2     <= hps_control_sync_r1;
        hps_control_sync_last_r <= hps_control_sync_r2;
    end
    
    wire hps_data_valid_pulse = hps_control_sync_r2 & ~hps_control_sync_last_r;

    // --- 2. Registradores de Dados e Status ---
    reg [31:0] hps_data_in_latched = 32'b0;
    reg        result_valid_reg = 1'b0;
    reg [29:0] result_data_reg = 30'b0;

    // --- 3. FSM de Handshake ---
    localparam STATE_IDLE   = 2'b00;
    localparam STATE_DECODE = 2'b01;
    localparam STATE_BUSY   = 2'b10;

    // INICIALIZAÇÃO CRÍTICA:
    // Garante que a FSM ligue no estado IDLE
    reg [1:0] fsm_state = STATE_IDLE; 

    // Lógica da FSM (Sem reset explícito)
    always @(posedge CLOCK_50) begin
        case (fsm_state)
            STATE_IDLE: begin
                if (hps_data_valid_pulse) begin
                    hps_data_in_latched <= hps_data_in;
                    fsm_state           <= STATE_DECODE;
                end
            end
            
            STATE_DECODE: begin
                if (is_ram_write_command) begin
                    fsm_state <= STATE_IDLE;
                end else if (is_ack_result_command) begin
                    fsm_state <= STATE_IDLE;
                end else begin
                    fsm_state <= STATE_BUSY;
                end
            end

            STATE_BUSY: begin
                if (controller_done) begin
                    result_valid_reg <= 1'b1;
                    result_data_reg  <= {27'b0, controller_zoom_level};
                    fsm_state <= STATE_IDLE;
                end
            end
        endcase
    end
    
    // --- 4. Lógica de Saída (Status para HPS) ---
    always @(*) begin
        fpga_status_out[0]    = (fsm_state == STATE_IDLE); // 'fpga_ready'
        fpga_status_out[1]    = result_valid_reg;
        fpga_status_out[31:2] = result_data_reg;
    end

    // --- 5. Lógica de Decodificação de Comandos ---
    wire decode_strobe = (fsm_state == STATE_DECODE);

    wire is_ram_write_command  = hps_data_in_latched[31];
    wire is_control_command    = !hps_data_in_latched[31];
    wire is_ack_result_command = (hps_data_in_latched[31:0] == 32'h0000_00FF); 

    // 5a. Decodificação para Escrita na RAM
    always @(posedge CLOCK_50) begin
        // O registrador 'ram_wren' é inicializado como 0 por padrão
        ram_wren <= decode_strobe & is_ram_write_command;
    end
    
    always @(*) begin
        ram_wraddress = hps_data_in_latched[14:0];
        ram_data_in   = hps_data_in_latched[23:16];
    end

    // 5b. Decodificação para Comandos de Controle (para o Controller)
    wire cmd_zoom_in    = hps_data_in_latched[0];
    wire cmd_zoom_out   = hps_data_in_latched[1];
    wire cmd_return     = hps_data_in_latched[2];
    wire cmd_sw_reset   = hps_data_in_latched[3];
    wire [1:0] cmd_algo = hps_data_in_latched[5:4];
    wire cmd_err_multi  = hps_data_in_latched[6];
    wire cmd_err_none   = hps_data_in_latched[7];

    // Este bloco também depende da inicialização padrão (0)
    always @(posedge CLOCK_50) begin
        // Gera pulsos de 1 ciclo
        cmd_reset_pulse    <= decode_strobe & is_control_command & cmd_sw_reset;
        cmd_zoom_in_pulse  <= decode_strobe & is_control_command & cmd_zoom_in;
        cmd_zoom_out_pulse <= decode_strobe & is_control_command & cmd_zoom_out;
        cmd_return_pulse   <= decode_strobe & is_control_command & cmd_return;

        // Sinais de Nível são atualizados e mantidos
        if (decode_strobe & is_control_command) begin
            cmd_algorithm_select    <= cmd_algo;
            cmd_multiple_sw_error   <= cmd_err_multi;
            cmd_no_sw_error         <= cmd_err_none;
        end
        
        // Lógica do ACK
        if (decode_strobe & is_ack_result_command) begin
            result_valid_reg <= 1'b0;
            result_data_reg  <= 30'b0;
        end
    end

endmodule